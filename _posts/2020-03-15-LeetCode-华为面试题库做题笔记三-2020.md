---
layout:     post                    # 使用的布局（不需要改）
title:      LeetCode-华为面试题库做题笔记三 # 标题 
subtitle:   第三次                      #副标题
date:       2020-03-15              # 时间
author:     ZXY                      # 作者
header-img:  img/post-bg-rwd.jpg   #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - LeetCode
    - HUAWEI
---

# 写在前面
华为面试题库刷题第三次整理。

# 203. 移除链表元素
>删除链表中等于给定值 val 的所有节点。<br/>
示例:<br/>
输入: 1->2->6->3->4->5->6, val = 6<br/>
输出: 1->2->3->4->5<br/>

解法：题目不难，重点是用多钟解法来解题。

## 递归
从尾部开始删除就不需要特别记录前一个节点，利用递归在这一点上就很讨巧。

代码：

    /**
    * Definition for singly-linked list.
    * struct ListNode {
    *     int val;
    *     ListNode *next;
    *     ListNode(int x) : val(x), next(NULL) {}
    * };
    */
    class Solution {
    public:
        ListNode* removeElements(ListNode* head, int val) {
            if(!head) return NULL;//递归边界
            head->next = removeElements(head->next,val);//递去：到底端再开始删除操作
            return head->val==val?head->next:head;//递归式
        }
    };

## 迭代
遍历链表，删除节点。每次判断的都是下一位，这样方便删除，然后再最后return位置特判头。

代码：

    class Solution {
    public:
        ListNode* removeElements(ListNode* head, int val) {
            if(!head) return NULL;
            ListNode *curr, * del;
            curr = head;
            while(curr->next){
                if(curr->next->val==val){//删除下一位
                    del = curr->next;
                    curr->next = del->next;
                    delete del;
                }
                else{
                    curr = curr->next;
                }
            }
            return head->val==val?head->next:head;//头元素特判
        }
    };

# 538. 把二叉搜索树转换为累加树
>给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。<br/>
例如：<br/>
输入: 原始二叉搜索树:<br/>
&emsp; &emsp; &emsp; &emsp; 5<br/>
&emsp; &emsp; &emsp; &ensp; / &ensp; \ <br/>
&emsp; &emsp; &emsp; 2&emsp;&emsp; 13<br/>
输出: 转换为累加树:<br/>
&emsp; &emsp; &emsp; &emsp; 18<br/>
&emsp; &emsp; &emsp; &ensp; / &emsp; \ <br/>
&emsp; &emsp; &emsp; 20&emsp;&emsp;13<br/>

解法：加上所有比这个节点大的，大的都在右边，所以从右往左遍历并累加就行了。

## 递归

代码：

    /**
    * Definition for a binary tree node.
    * struct TreeNode {
    *     int val;
    *     TreeNode *left;
    *     TreeNode *right;
    *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
    * };
    */
    class Solution {
    private:
        int sum = 0;
    public:
        TreeNode* convertBST(TreeNode* root) {
            if(root){
                convertBST(root->right);//遍历右子树
                sum += root->val;//累加
                root->val = sum;//更新数值
                convertBST(root->left);//遍历左子树
            }
            return root;
        }
    };

## 迭代
其实和递归大同小异，只不过把递归过程放进了循环里面。

代码：

    class Solution {
    public:
        TreeNode* convertBST(TreeNode* root) {
            int sum = 0;
            TreeNode* t = root;
            vector<TreeNode*> s;
            while(!s.empty()||t){
                while(t){
                    s.push_back(t);
                    t = t->right;
                }
                t = s.back();
                s.pop_back();
                sum += t->val;
                t -> val = sum;
                t = t -> left;
            }
            return root;
        }
    };

# 820. 单词的压缩编码
>给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。<br/>
例如，如果这个列表是 ["time", "me", "bell"]，我们就可以将其表示为 S = "time#bell#" 和 indexes = [0, 2, 5]。<br/>
对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 "#" 结束，来恢复我们之前的单词列表。<br/>
那么成功对给定单词列表进行编码的最小字符串长度是多少呢？<br/>

>提示：<br/>
1. 1 <= words.length <= 2000<br/>
2. 1 <= words[i].length <= 7<br/>
3. 每个单词都是小写字母 。<br/>

解法：
## 后缀字符串
一个数组如果是另外一个字符串的后缀字符串，就会被删除，因为数据的单词长度不超过7，穷举即可，为了方便除重和删除操作，我们这里利用set数据结构。

代码：

    class Solution {
    public:
        int minimumLengthEncoding(vector<string>& words) {
            int l = words.size();
            set<string> s(words.begin(),words.end());
            for(auto word:words)
                for(int i=1; i<word.length(); i++)
                    s.erase(word.substr(i));
            int res = 0;
            for(auto i = s.begin(); i != s.end(); i++)
                res += (*i).length()+1;
            return res;
        }
    };

## 字典树
上面那种方法明显不具有课扩展性，穷举单词的后缀字符串很繁琐，这题可以利用字典树来进行计算。<br/>
去找到是否不同的单词具有相同的后缀，我们将其反序之后放入一棵字典树中（前缀树）。例如，我们有 "time" 和 "me"，可以将 "emit" 和 "em" 放入字典树中。<br/>
然后，字典树的叶子节点（没有孩子的节点）就代表没有后缀的词，统计 sum(word.length + 1 for word in words)。<br/>

代码：

    class Solution {
    public:
        struct TreeNode {
            int len;
            map<char, TreeNode*> next;
            TreeNode() : len(0) {};
        };
        TreeNode* root;
        Solution() {
            root = new TreeNode();
        }
        int minimumLengthEncoding(vector<string>& words) {
            int res = 0;
            for (auto& w : words) {
                auto node = root;
                for (int i = w.size() - 1; i >= 0; --i) {
                    char c = w[i];
                    if (node->next.count(c) == 0) {
                        node->next[c] = new TreeNode();
                    }
                    node = node->next[c];
                    if (node->len > 0) {
                        res -= node->len;
                        node->len = 0;
                    }
                }
                if (node->len == 0 && node->next.empty()) {
                    node->len = 1 + w.size();
                    res += node->len;
                }
            }
            return res;
        }
    };

# 1109. 航班预订统计
>这里有 n 个航班，它们分别从 1 到 n 进行编号。<br/>
我们这儿有一份航班预订表，表中第 i 条预订记录 bookings[i] = [i, j, k] 意味着我们在从 i 到 j 的每个航班上预订了 k 个座位。<br/>
请你返回一个长度为 n 的数组 answer，按航班编号顺序返回每个航班上预订的座位数。<br/>

>提示：<br/>
1. 1 <= bookings.length <= 20000
2. 1 <= bookings[i][0] <= bookings[i][1] <= n <= 20000
3. 1 <= bookings[i][2] <= 10000

解法：
## 暴力模拟（超时）
看范围就知道会爆了，不过还是手贱试了一下。

代码：

    class Solution {
    public:
        vector<int> corpFlightBookings(vector<vector<int>>& bookings, int n) {
            vector<int> a(n+1,0);
            for(auto x : bookings){
                for(int i=x[0]; i<=x[1]; i++)
                    a[i] += x[2];
            }
            a.erase(a.begin());
            return a;
        }
    };

## 扫描法
1. 换一种思路理解题意，将问题转换为：某公交车共有 n 站，第 i 条记录 bookings[i] = [i, j, k] 表示在 i 站上车 k 人，乘坐到 j 站，在 j+1 站下车，需要按照车站顺序返回每一站车上的人数
2. 根据 1 的思路，定义 counter[] 数组记录每站的人数变化，counter[i] 表示第 i+1 站。遍历 bookings[]：bookings[i] = [i, j, k] 表示在 i 站增加 k 人即 counters[i-1] += k，在 j+1 站减少 k 人即 counters[j] -= k
3. 遍历（整理）counter[] 数组，得到每站总人数： 每站的人数为前一站人数加上当前人数变化 counters[i] += counters[i - 1]

代码：

    class Solution {
    public:
        vector<int> corpFlightBookings(vector<vector<int>>& bookings, int n) {
            vector<int> a(n,0);
            for(auto x : bookings){
                if(x[0]-1>=0)a[x[0]-1] += x[2];
                if(x[1]<n)a[x[1]] -= x[2];
            }
            for(int i=1; i<n; i++){
                a[i] += a[i-1];
            }
            return a;
        }
    };