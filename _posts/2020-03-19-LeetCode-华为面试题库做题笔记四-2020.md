---
layout:     post                    # 使用的布局（不需要改）
title:      LeetCode-华为面试题库做题笔记四 # 标题 
subtitle:   第四次                      #副标题
date:       2020-03-19              # 时间
author:     ZXY                      # 作者
header-img:  img/post-bg-rwd.jpg   #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - LeetCode
    - HUAWEI
---

# 写在前面
华为面试题库刷题第四次整理。

# 1245. 树的直径
>给你这棵「无向树」，请你测算并返回它的「直径」：这棵树上最长简单路径的 边数。<br/>
我们用一个由所有「边」组成的数组 edges 来表示一棵无向树，其中 edges[i] = [u, v] 表示节点 u 和 v 之间的双向边。<br/>
树上的节点都已经用 {0, 1, ..., edges.length} 中的数做了标记，每个节点上的标记都是独一无二的。<br/>

>提示：
>1. 0 <= edges.length < 10^4
>2. edges[i][0] != edges[i][1]
>3. 0 <= edges[i][j] <= edges.length
>4. edges 会形成一棵无向树

解法：很明显的dfs题目，但是最关键的是如何dfs。

## 暴力dfs（超时）
我写了一个很傻的遍历dfs，对所有只有一边相连的点进行一次dfs，其实很明显就可以发现有很多冗余的搜索。

代码：

    class Solution {
    private:
        int res = 0;
        int l = 0;
    public:
        void dfs(vector<vector<int>>& b, int k, int d){
            bool f = false;
            for(int i=0; i<l; i++){
                if(b[k][i]==1){
                    f = true;
                    b[k][i] = 0;
                    b[i][k] = 0;
                    
                    dfs(b,i,d+1);
                    b[k][i] = 1;
                    b[i][k] = 1;
                }
            }
            res = max(res,d);
        }
        int treeDiameter(vector<vector<int>>& edges) {
            if(edges.empty()) return 0;
            l = edges.size();
            vector<int> a(l+2,0);
            vector<vector<int>> b(l+1,vector<int>(l+1,0));
            for(int i=0; i<l; i++){
                a[edges[i][0]]++;
                a[edges[i][1]]++;
                b[edges[i][0]][edges[i][1]] = 1;
                b[edges[i][1]][edges[i][0]] = 1;
            }
            /*for(int i=0; i<=l; i++)
                cout<<a[i]<<' ';
            cout<<endl;*/
            for(int i=0; i<=l; i++){
                if(a[i]==1){
                    dfs(b,i,0);
                }
            }
            return res;
        }
    };

## 优化的dfs
1. 随机选定一个点作为根节点，这里我们选0。
2. 从root出发进行一次dfs，记录最远节点p1。
3. 从p1节点出发进行一次dfs，此时记录下来的深度就是答案。

代码：

    class Solution {
    private:
        vector<vector<int>> graph;
        vector<bool> visited;
    public:
        int treeDiameter(vector<vector<int>>& edges) {
            // build graph
            int l = edges.size();
            graph.resize(l+2);
            visited.resize(l+2);
            for(auto e: edges) {
                graph[e[0]].push_back(e[1]);
                graph[e[1]].push_back(e[0]);
            }
            pair<int, int> p1, p2;
            p1 = { -1, 0 };
            dfs(0, 0, p1);
            visited.assign(l+2, false);
            p2 = { -1, 0 };
            dfs(p1.first, 0, p2);
            return p2.second;
        }
        void dfs(int u, int depth, pair<int, int>& p) {
            visited[u] = true;
            if(depth > p.second) {
                p.second = depth;
                p.first = u;
            }
            for(int v: graph[u])
                if(!visited[v])
                    dfs(v, depth + 1, p);
                
        }
    };

# 1151. 最少交换次数来组合所有的 1
>给出一个二进制数组 data，你需要通过交换位置，将数组中 任何位置 上的 1 组合到一起，并返回所有可能中所需 最少的交换次数。

>提示：
>1. 1 <= data.length <= 10^5
>2. 0 <= data[i] <= 1

解法：滑动窗口很适合这题，算出1的个数为k，那么窗口的大小就是p，滑动过程中更新窗口内的1的个数，记录下最大的个数q，p-q就是答案。

代码：

    class Solution {
    public:
        int minSwaps(vector<int>& data) {
            if(data.empty()) return 0;
            int sum = 0;
            for(int i=0; i<data.size(); i++)
                sum += data[i];
            int res(0),c(0);
            for(int i=0; i<=sum-1; i++)
                c += data[i];
            res = max(res,c);
            for(int i=sum; i<data.size(); i++){
                c += data[i];
                c -= data[i-sum];
                res = max(res,c);
            }
            return (sum-res);
        }
    };

