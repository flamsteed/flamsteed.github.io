---
layout:     post                    # 使用的布局（不需要改）
title:      LeetCode-华为面试题库做题笔记二 # 标题 
subtitle:   第二次                      #副标题
date:       2020-03-10              # 时间
author:     ZXY                      # 作者
header-img:  img/post-bg-rwd.jpg   #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - LeetCode
    - HUAWEI
---

# 写在前面
华为面试题库刷题第二次整理

# 136. 只出现一次的数字
>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。<br/>
说明：<br/>
你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？<br/>

解法：要求时间复杂度O(N)，空间复杂度O(1)，讲道理，想不出来，只相处一种排序之后遍历一遍得出答案的方法，时间复杂度O(N*log(N))，空间复杂度O(1)。

## 排序
排序后遍历，没有出现两次就是答案<br/>
代码：

    class Solution {
    public:
        int singleNumber(vector<int>& nums) {
            sort(nums.begin(),nums.end());
            int res = INT_MAX;
            for(int i=0; i<nums.size();i+=2)
                if(i+1<nums.size() && nums[i]!=nums[i+1]){
                    res = nums[i];
                    break;
                }
            if(res==INT_MAX) res = nums[nums.size()-1];
            return res;
        }
    };

## 集合
集合可以自动去重，然后求和乘2再减去原来的和就是答案，时间复杂度O(N)，空间复杂度O(N)。<br/>
代码：

    class Solution {
    public:
        int singleNumber(vector<int>& nums) {
            set<int> s;
            int sum1(0),sum2(0);
            for(auto x:nums){
                s.insert(x);
                sum1 += x;
            }
            for(auto x:s){
                sum2 += x;
            }
            return (sum2*2-sum1);
        }
    };

## 位运算
又是位运算，这东西是真的骚，反正没做过基本想不出来，不过这次做过了以后就不能忘了。<br/>
根据位运算异或的性质，可以得到以下的规律：<br/>
1. a ^ 0 = a;
2. a ^ a = 0;
3. a ^ b ^ c = a ^ c ^ b;

所以，根据以上的规律，所有数字异或一边，就会剩下答案。

代码：

    class Solution {
    public:
        int singleNumber(vector<int>& nums) {
            int res = 0;
            for(auto x:nums)
                res ^= x;
            return res;
        }
    };